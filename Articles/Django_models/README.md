# Что такое ORM и его преимущества.

ORM (Object-Relation Mapping) – технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

Пример использования ORM и обычного SQL запроса:


ORM:

```python
from django.db import models

class Person(models.Model):
first_name = models.CharField(max_length=30)
last_name = models.CharField(max_length=30)
```

first_name  и last_name  это поля нашей модели. В них нужно указывать тип поля и его атрибуты. Здесь мы указали что наши поля текстовые и максимальная их длина может быть 30 символов.


SQL:

```mysql
CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

Тут создается точно такая же база данных, но в отличии от ORM мы прописываем все ограничения в ручную. Огромный плюс работы с ORM в том, что там половину запросов делается автоматически, там нам не надо указывать pk (primary key) и давать точные команды для полей. Второй плюс, это читаемость кода, он становиться компакнтнее и аккуратнее для программиста. 

---

## Связь моделей и их поля
### Поля

Самая важная часть модели - и единственная обязательная часть модели - это список полей базы данных, которые она определяет. Поля задаются атрибутами класса. Будьте осторожны, чтобы имена полей не противоречили API модели, например, clean, save или delete.


В orm очень много видов полей, более детально с ними можно ознакомиться [тут](https://docs.djangoproject.com/en/4.2/ref/models/fields/#field-types). Ниже я показал часто используемые поля:


- IntegerField - принимает числовые значения тип int от -2147483648 до 2147483647
- BigIntegerField - 64 битное поле, которое варьируется от -9223372036854775808 до 9223372036854775807
- BooleanField - принимает только True или False
- CharField - строковое поле, которое обрабатывает как небольшие, так и большие строки
- DateField - принимает дату. Есть дополнительные параметры, такие как: auto_now и auto_now_add (Подробнее тут [Ссылка](https://docs.djangoproject.com/en/4.2/ref/models/fields/#datefield))
- DateTimeField - принимает дату и время
- FloatField - принимает числовое значение в формате float

### Связь

Так же модели могут быть связаны (Relationship fields), для этого используются такие параметры как: ForeignKey, ManyToManyField и OneToOneField

#### ForeignKey

Подробнее разберем пример ForeignKey.
Пример использования:

```python
class Cart(models.Model):
    customer = models.ForeignKey(User, on_delete=models.PROTECT)
    ...
```

В данном примере мы создаем связь нашей модели со встроенной моделью Django, для создания корзины. 

Параметр on_delete обязателен. Он обрабатывает ситуации, если поле модели захотят удалить, в нашем случае какого-то user, то метод PROTECT не даст этого сделать, до того момента, пока мы не удалим корзину этого пользователя. 

Так же у on_delete есть и другие параметры, такие как:
- CASCADE - в случае удаления пользователя, вместе с ним удалиться его корзина и остальные связанные с ним поля.
- SET_NULL - установит ForeignKey равным null; это возможно, только если null равен True.
- SET_DEFAULT - установит для ForeignKey значение по умолчанию; для ForeignKey должно быть установлено значение по умолчанию.
- DO_NOTHING - не предпринимает никаких действий.
- RESTRICT - предотвращает удаление объекта со ссылкой, вызывая RestrictedError (подкласс django.db.IntegrityError). В отличие от PROTECT, удаление объекта со ссылкой разрешено, если он также ссылается на другой объект, который удаляется в той же операции, но через отношение CASCADE.

Примером послужит данный код:

```python
class Artist(models.Model):
    name = models.CharField(max_length=10)


class Album(models.Model):
    artist = models.ForeignKey(Artist, on_delete=models.CASCADE)


class Song(models.Model):
    artist = models.ForeignKey(Artist, on_delete=models.CASCADE)
    album = models.ForeignKey(Album, on_delete=models.RESTRICT)
```

Пример использования:

```python
>>> artist_one = Artist.objects.create(name="artist one")
>>> artist_two = Artist.objects.create(name="artist two")
>>> album_one = Album.objects.create(artist=artist_one)
>>> album_two = Album.objects.create(artist=artist_two)
>>> song_one = Song.objects.create(artist=artist_one, album=album_one)
>>> song_two = Song.objects.create(artist=artist_one, album=album_two)
>>> album_one.delete()
# Raises RestrictedError.
>>> artist_two.delete()
# Raises RestrictedError.
>>> artist_one.delete()
(4, {'Song': 2, 'Album': 1, 'Artist': 1})
```

---

Еще одним важным параметром в связи баз данных является related_name.

Если вы не укажете имя related_name для обратной связи, по умолчанию Django будет использовать имя исходной модели с суффиксом _set в качестве имени related_name.

Пример свзяи без related_name:

```python
class Blog(models.Model):
    name = models.CharField(max_length=20)

class Post(models.Model):
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
```

```python
>>> b = Blog.objects.get(id=1)
>>> b.post_set.all() # Возвращает все объекты Post, связанные с Blog
```

Мы можем использовать этот метод, для более удобных ORM запросов, как показано ниже: 

```python
class Blog(models.Model):
    name = models.CharField(max_length=20)

class Post(models.Model):
    blog = models.ForeignKey(Blog, related_name='posts', on_delete=models.CASCADE)
```

```python
>>> b = Blog.objects.get(id=1)
>>> b.posts.all() # Возвращает все объекты Post, связанные с Blog
```

---
При связей моделей Django ссылается на pk ключ, но это поведение можно корректировать с помощью to_field. Если вы ссылаетесь на другое поле, это поле должно иметь значение unique=True.

---

#### ManyToManyField

Связь Многие ко Многим (m2m)

Все параметры которые относяться к ForeignKey, можно использовать и для m2m таблиц. 

За кулисами Django создает промежуточную таблицу join для представления отношения "многие-ко-многим". По умолчанию имя этой таблицы генерируется с использованием имени поля "многие-ко-многим" и имени таблицы для модели, которая его содержит. Поскольку некоторые базы данных не поддерживают имена таблиц определенной длины, эти имена таблиц будут автоматически усечены и будет использован хэш уникальности, например, author_books_9cdf. Вы можете вручную указать имя присоединяемой таблицы с помощью опции db_table.

Пример использования m2m таблицы с самой собой.
В Твиттере вы следите за людьми. Возможно, некоторые люди следуют за вами, но все отношения в одном направлении, асимметричные. В Django вы можете реализовать это с помощью отношений ManyToMany. Нам не нужна специальная сквозная модель для этого, но предположим, что мы хотим прикрепить некоторые метаданные к этим отношениям. Ниже приведен пример кода для базы данных людей в стиле twitter и их отношений друг с другом. Отношения содержат столбец статуса, указывающий, следует ли конкретный пользователь за другим или блокирует его:

```python
class Person(models.Model):
    name = models.CharField(max_length=100)
    relationships = models.ManyToManyField('self', through='Relationship',
                                           symmetrical=False,
                                           related_name='related_to')

    def __unicode__(self):
        return self.name

RELATIONSHIP_FOLLOWING = 1
RELATIONSHIP_BLOCKED = 2
RELATIONSHIP_STATUSES = (
    (RELATIONSHIP_FOLLOWING, 'Following'),
    (RELATIONSHIP_BLOCKED, 'Blocked'),
)

class Relationship(models.Model):
    from_person = models.ForeignKey(Person, related_name='from_people')
    to_person = models.ForeignKey(Person, related_name='to_people')
    status = models.IntegerField(choices=RELATIONSHIP_STATUSES)
```

Если вы не хотите симметрии в отношениях "многие-ко-многим" с self, установите symmetrical в False. Это заставит Django добавить дескриптор для обратного отношения, позволяя отношениям ManyToManyField быть несимметричными.

Так же мы можем настроить промежуточную таблицу c помощью through.

```python
class Order(models.Model):
    customer = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ManyToManyField(Product, through='OrderProduct')
    timestamp = models.DateTimeField(auto_now_add=True)


class OrderProduct(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField(default=1)
```

Таким образом, Django будет связывать 2 модели через промежуточную. У модели по середине мы можем указывать любые данные, которые только нам нужны. Тем самым можно как в этом примере реализовать корзину, в которой будет лежать количество добавленного товара.


#### OneToOneField 

Отношение "один к одному". Концептуально это похоже на ForeignKey с unique=True, но "обратная" сторона отношения будет напрямую возвращать один объект.

### Model Meta options

Мета-опции модели абстрактные базовые классы полезны, когда вы хотите поместить некоторую общую информацию в ряд других моделей. Вы пишете свой базовый класс и ставите abstract=True в классе Meta. Эта модель не будет использоваться для создания какой-либо таблицы базы данных. Вместо этого, когда она будет использоваться в качестве базового класса для других моделей, ее поля будут добавлены к полям дочернего класса.

```python
class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

class Meta:
    abstract = True
    
def __str__(self):
    return f'{self.name}'

class Student(CommonInfo):
    home_group = models.CharField(max_length=5)
```

Это очень хорошая практика, если вам надо создать базовую модель, от которой вы уже будете наследоваться и создавать новые сущности. Не рекомендуется злоупотреблять, тк вы начнете плодить очень много мало отличающихся моделей, если стоит задача создавать много баз, то лучше использовать связи.

Django создаст такую таблицу, под названием open_student, но таблицу CommonInfo он создавать не будет, тк она абстрактная.

| id |  name   |  age  | home_group |
|:--:|:-------:|:-----:|:----------:|
| 1  |  Ivan   |  23   |   FAKEA    |
| 2  |  Antom  |  20   |   LRXRS    |


Точно так же, мы можем наследоваться от многих классов.

```python
from django.db import models


class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True
        ordering = ["name"]


class Unmanaged(models.Model):
    class Meta:
        abstract = True
        managed = False


class Student(CommonInfo, Unmanaged):
    home_group = models.CharField(max_length=5)

    class Meta(CommonInfo.Meta, Unmanaged.Meta):
        pass
```

---

##### Теперь рассмотрим просто наследования без абстракта, что поменяется?

```python
class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    def __str__(self):
        return f'{self.name}'

class Student(CommonInfo):
    home_group = models.CharField(max_length=5) 
```

У нас поменяется сама база, она создаст 2 таблицы, которые будут связаны в одностороннем направлении (не синхронно). 

open_commoninfo

| id |  name   |  age  |
|:--:|:-------:|:-----:|
| 1  |  Ivan   |  23   |
| 2  |  Antom  |  20   |

open_student

| commoninfo_ptr_id | home_group |
|:-----------------:|:----------:|
|         1         |   FAKEA    |
|         2         |   LRXRS    |

```python
>>> Student.objects.create(name='Ivan', age=23, home_group='FAKEA')
<Student: Ivan>
>>> Student.objects.create(name='Anton', age=20, home_group='LRXRS')
<Student: Anton>
```
После заполнение полей у нас получится таблица указанная выше. 

Обратите внимание, что у нас возвращается не объект, а его имя. Это происходит благодоря магическому методу `__str__`.

```python
>>> Student.objects.get(id=1)
<Student: Ivan>
>>> Student.objects.get(id=1).age
23
>>> Student.objects.get(id=1).student
<Student: Ivan>
>>> Student.objects.get(id=1).home_group
'FAKEA'
```

Мы можем из модели студент получить всего его данные как из его таблицы, так и из таблицы open_commoninfo. 

Но если мы попробуем сделать зеркальный запрос из таблицы open_commoninfo, то получим такую ошибку:

```python
>>> CommonInfo.objects.get(id=1).home_group
...
AttributeError: 'CommonInfo' object has no attribute 'home_group'
```
Это и есть не симметричная база данных.

---

#### Proxy model 

Используется когда вам необходимо расширить функционал модели, но вы не хотите изменять основную модель. Выглядит это так:

```python
class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)


class MyPerson(Person):
    class Meta:
        proxy = True

    def do_something(self):
        # ...
        pass
```
```python
>>> p = Person.objects.create(first_name="foobar")
>>> MyPerson.objects.get(first_name="foobar")
<MyPerson: foobar>
```

Мы можем обращаться как к оригинальной модели, так и к нашей “прослойке”.

---

#### Model methods

В наших моделях мы можем создавать методы. Выглядят это так:


```python
class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime

        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):
        "Returns the person's full name."
        return f"{self.first_name} {self.last_name}"
```

Теперь мы можем обращаться к этим полям вот так:

```python
Person.objects.get(id=1).baby_boomer_status
```

Или 

```python
Person.objects.get(id=1).full_name
```

Подробнее про @property можно почитать [тут](https://stackoverflow.com/questions/58558989/what-does-djangos-property-do).
